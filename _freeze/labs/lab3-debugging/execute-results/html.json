{
  "hash": "bb9a16a89b644c8776a1cf558e3b8f05",
  "result": {
    "markdown": "---\ntitle: \"Lab 3: Debugging\"\nauthor: \"Ahmed Eldeeb\"\ndate: \"2023-08-21\"\neval: false\nformat:\n  pdf:\n    documentclass: article\n    margin-left: 30mm\n    margin-right: 30mm\n    toc: true\n  html:\n    theme: cosmo\n    css: ../styles.css\n    toc: true\n    code-copy: true\n    code-block-background: true\nexecute:\n  freeze: auto\n---\n\n## Debugging\n\nToday we're going to explore the concept of debugging and some of the tooling that allows for debugging python code.\n\nIt's widely recognized and accepted that any sizeable code base will have a non-trivial number of bugs (where does the term come from?). The main goal of testing is to make sure the main expected cases are behaving correctly.\n\nSometime you code doesn't do what you expect or want it to do, and it's not clear just by reading through it, what the problem is. \n\nIn interpreted languages (esp. those with interactive shells like python) one can sometimes run the code piece by piece and inspect the state of the variables.\n\nIf the code involves a loop or a function, a common practice is to judiciously place a few print statements that dump the state of some variables to the terminal so that you can spot the problem by tracing through it.\n\nWhen the code involves multiple functions and complex state, this strategy starts to break down. This is where you start rolling up your sleeves and invoking a debugger!\n\nDebugging can be a slow process, so you typically start a debugging session by deciding which line in your code you would like to start tracing the behavior from, and you place a breakpoint. Then you can have the debugger run the program up to that point and stop at it, allowing you to:\n\n1- inspect the current state of variables\n2- step through the code line by line\n3- step over or into functions as they are called\n4- resume program execution\n\n## advanced debugging\n\nSome bugs are really tricky to catch. Those are typically the bugs that happen very rarely, and in unclear circumstances. In statistical computing and data analysis settings these might be conditions that happen in iterative algorithms sometimes, but not very often, and can be hard to reproduce.\n\nOne way to deal with these bugs is to start the debugging session with placing one or more **conditional** breakpoints. These are similar to regular breakpoints but are not going to cause the debugger to stop the execution of the program and hand you the controls unless a specific condition (that you specify) evaluates to true as the program is executing that particular line of code. You may use some conditions that are similar to what you would place in an assert statement (conditions that shouldn't happen) or any other conditions that you think may be associated with the occurrence of the anomalous behavior your are debugging.\n\n## Integrated GUI debugger (with VS Code)\n\nToday we will experiment with the visual debugging tools integrated with IDEs. We will do that in VS Code (unless you have another IDE with debugger integration). We will load a piece of code, go through it to understand what it does, then try to discover the problem with it and fix it.\n\nHere's a piece of code that implements the binary search algorithm to locate the first occurence of a number in a list of numbers:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport math\ndef binary_search(lst, T):\n    L = 0\n    R = len(lst) - 1\n    while L < R:\n        m = math.floor((L + R) / 2)\n        if lst[m] <= T:\n            L = m + 1\n        else:\n            R = m - 1\n    if lst[L] == T:\n        return L\n    return -1\n```\n:::\n\n\nThere are a couple of things not quite right with this implementation, even though it will run and produce correct results for some cases.\n\nHere's another piece of code implementing merge sort (also with some bugs in it):\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndef merge_sort(lst):\n    n = len(lst)\n    if n == 1:\n        return lst\n    return merge(merge_sort(lst[:n//2]), merge_sort(lst[n//2:]))\n\ndef merge(lst1, lst2):\n    merged = []\n    i, j = 0,0\n    while i < len(lst1) and j < len(lst2):\n        if i < len(lst1) and j < len(lst2) and lst1[i] < lst2[j]:\n            merged.append(lst1[i])\n            i += 1\n        else:\n            merged.append(lst1[j])\n            j += 1\n    while i < len(lst1):\n        merged.append(lst1[i])\n        i += 1\n    while j < len(lst2):\n            merged.append(lst2[j])\n            j += 1\n    return merged\n        \nmerge_sort([3,1,5,1,6,3,9,12,8])\n```\n:::\n\n\nYou can use this to practice stepping inside functions, and thinking about recursion.\n\nIncidentally, if you first sort, then find, you can get the quantile of a particular value within a collection (you'll need to adjust the binary search a little to achieve this).\n\nAlternatively you could start by implementing (without using any existing functions) a function that inverst the order of the words in a string, and debug it until it works.\n\nHere's a version of this function where I injected a couple of bugs, if you prefer to start from there:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef reverse_words(input):\n    working = list(input)\n    invert(working)\n    start = 0\n    for i, c in enumerate(working):\n        if c == ' ' and i != start:\n            invert(working, start, i)\n            start = i+1\n    return ''.join(working)\n\ndef invert(lst, start=None, end=None):\n    if None == start:\n        start = 0\n    if None == end:\n        end = len(lst)-1\n    \n    while start < end:\n        tmp = lst[start]\n        lst[start] = lst[start]\n        lst[end] = tmp\n        start += 1\n        end -= 1\n\nreverse_words(\"These are my words.   I have spoken!\")\n```\n:::\n\n\nNext time we will touch briefly on how to do debugging without an IDE with debugger integration.\n\n",
    "supporting": [
      "lab3-debugging_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}