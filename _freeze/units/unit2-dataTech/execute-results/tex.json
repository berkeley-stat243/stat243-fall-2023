{
  "hash": "1a3fc1257f9827f11da9ba52233e0886",
  "result": {
    "markdown": "---\ntitle: \"Data technologies, formats, and structures\"\nauthor: \"Chris Paciorek\"\ndate: \"2023-08-21\"\nformat:\n  pdf:\n    documentclass: article\n    margin-left: 30mm\n    margin-right: 30mm\n    toc: true\n  html:\n    theme: cosmo\n    css: ../styles.css\n    toc: true\n    code-copy: true\n    code-block-background: true\nexecute:\n  freeze: auto\n---\n\n\n\n[PDF](./unit2-dataTech.pdf){.btn .btn-primary}\n\nReferences (see [syllabus](../syllabus) for links):\n\n-   Adler\n-   Nolan and Temple Lang, XML and Web Technologies for Data Sciences with R.\n-   Murrell, Introduction to Data Technologies.\n-   SCF tutorial: [Working with large datasets in SQL, R, and Python](https://berkeley-scf.github.io/tutorial-databases/)\n\n(Optional) Videos:\n\nThere are four videos from 2020 in the bCourses Media Gallery that you\ncan use for reference if you want to:\n\n1.  Text files and ASCII\n2.  Encodings and UTF-8\n3.  HTML\n4.  XML and JSON\n\nNote that the videos were prepared for a version of the course that used\nR, so there are some differences from the content in the current version of\nthe unit that reflect translating between R and Python. I'm not sure how\nhelpful they'll be, but they are available.\n\n# 1. Data storage and file formats on a computer\n\nThis unit largely covers topics relevant for early on in the data analysis pipeline: getting data,\nreading data in, writing data out to disk, and webscraping. We'll focus\non doing these manipulations in Python, but the concepts and tools involved\nare common to other languages, so familarity with these in Python should\nallow you to pick up other tools easily. The main downside to\nworking with datasets in Python (true for R and most other languages as well) is that the entire\ndataset resides in memory, so using standard Python tools can be problematic\nin some cases; we'll discuss some alternatives later.  Python (and similar\nlanguages) has the capability to read in a wide variety of file formats.\n\n## Text and binary files\n\nIn general, files can be divided into text files and binary files. In\nboth cases, information is stored as a series of bits. Recall that a bit\nis a single value in base 2 (i.e., a 0 or a 1), while a byte is 8 bits.\n\nA **text file** is one in which the bits in the file encode individual\ncharacters. Note that the characters can include the digit characters\n0-9, so one can include numbers in a text file by writing down the\ndigits needed for the number of interest. Examples of text file formats\ninclude CSV, XML, HTML, and JSON.\n\nText files may be simple ASCII files (i.e., files encoded using ASCII)\nor files in other encodings such as UTF-8, both covered in Section 5.\n[ASCII](http://en.wikipedia.org/wiki/ASCII) files have 8 bits (1 byte)\nper character and can represent 128 characters (the 52 lower and upper\ncase letters in English, 10 digits, punctuation and a few other things\n-- basically what you see on a standard US keyboard). UTF-8 files have\nbetween 1 and 4 bytes per character.\n\nSome text file formats, such as JSON or HTML, are not easily interpretable/manipulable\non a line-by-line basis (unlike, e.g., CSV), so they are not as amenable\nto processing using shell commands.\n\n\nA **binary file** is one in which the bits in the file encode the\ninformation in a custom format and not simply individual characters.\nBinary formats are not (easily) human readable but can be more\nspace-efficient and faster to work with (because it can allow random\naccess into the data rather than requiring sequential reading). The\nmeaning of the bytes in such files depends on the specific binary format\nbeing used and a program that uses the file needs to know how the format\nrepresents information. Examples of binary files include netCDF files, Python pickle files,\nR data (e.g., .Rda) files, , and compiled code files.\n\nNumbers in binary files are usually stored as 8 bytes per number. We'll\ndiscuss this much more in Unit 8.\n\n## Common file types\n\nHere are some of the common file types, some of which are text formats and some of which are binary formats.\n\n1.  'Flat' text files: data are often provided as simple text files.\n    Often one has one record or observation per row and each column or\n    field is a different variable or type of information about the\n    record. Such files can either have a fixed number of characters in\n    each field (*fixed width format*) or a special character (a *delimiter*)\n    that separates the fields in each row. Common delimiters are tabs,\n    commas, one or more spaces, and the pipe (\\|). Common file\n    extensions are `.txt` and `.csv`. Metadata (information about the\n    data) are often stored in a separate file. CSV files are quite\n    common, but if you have files where the data contain commas, other\n    delimiters might be preferable. Text can be put in quotes in CSV files, and\n    this can allow use of commas within the data. This is difficult to\n    deal with from the command line, but `read_table()` in Pandas handles this situation.\n\n    -   One occasionally tricky difficulty is as follows. If you have a\n        text file created in Windows, the line endings are coded\n        differently than in UNIX. Windows uses a newline\n        (the ASCII character `\\n`)\n        and a carriage return (the ASCII character `\\r`) whereas\n        UNIX uses onlyl a  newline in UNIX). There are\n        UNIX utilities (`fromdos` in\n        Ubuntu, including the SCF Linux machines and `dos2unix` in other\n        Linux distributions) that can do the necessary conversion. If\n        you see `\\^M` at the end of the lines in a file, that's the tool\n        you need. Alternatively, if you open a UNIX file in Windows, it\n        may treat all the lines as a single line. You can fix this with\n        `todos` or `unix2dos`.\n\n2.  In some contexts, such as textual data and bioinformatics data, the\n    data may be in a text file with one piece of information per row, but\n    without meaningful columns/fields.\n\n3.  Data may also be in text files in formats designed for data\n    interchange between various languages, in particular XML or JSON.\n    These formats are \"self-describing\"; namely the metadata is part of\n    the file. The `lxml` and `json` packages are useful for\n    reading and writing from these formats. More in Section 4.\n\n4.  You may be scraping information on the web, so dealing with text\n    files in various formats, including HTML. The `requests` and `BeautifulSoup`\n    packages are useful for reading HTML.\n\n5.  In scientific contexts, netCDF (`.nc`) (and the related HDF5) are\n    popular format for gridded data that allows for highly-efficient\n    storage and contains the metadata within the file. The basic\n    structure of a netCDF file is that each variable is an array with\n    multiple dimensions (e.g., latitude, longitude, and time), and one\n    can also extract the values of and metadata about each dimension.\n    The `netCDF4` package in Python nicely handles working with netCDF files.\n\n6.  Data may already be in a database or in the data storage format of another\n    statistical package (`Stata`, `SAS`, `SPSS`, etc.). The `Pandas`\n    package in Python has  capabilities for importing Stata\n    (`read_stata`), SPSS (`read_spss`), and SAS (`read_sas`) files, among others.\n\n7.  For Excel, there are capabilities to read an Excel file (see the\n    `read_excel` function in Pandas), but you can also\n    just go into Excel and export as a CSV file or the like and then\n    read that into Python. In general, it's best not to pass around data\n    files as Excel or other spreadsheet format files because (1) Excel\n    is proprietary, so someone may not have Excel and the format is\n    subject to change, (2) Excel imposes limits on the number of\n    rows, (3) one can easily manipulate text files such as CSV using\n    UNIX tools, but this is not possible with an Excel file, (4) Excel\n    files often have more than one sheet, graphs, macros, etc., so\n    they're not a data storage format per se.\n\n8.  Python can easily interact with databases (SQLite, PostgreSQL, MySQL,\n    Oracle, etc.), querying the database using SQL and returning results\n    to Python. More in the big data unit and in the large datasets tutorial\n    mentioned above.\n\n## CSV vs. specialized formats such as Parquet\n\nCSV is a common format (particularly in some disciplines/contexts) and has the advantages of being simple to understand, human readable, and readily manipulable by line-based processing tools such as shell commands. However, it has various disadvantages:\n\n  - storage is by row, which will often mix values of different types;\n  - extra space is taken up by explicitly storing commas and newlines; and\n  - one must search through the document to find a given row or value -- e.g., to find the 10th row, we must search for the 9th newline and then read until the 10th newline.\n\nA popular file format that has some advantages over plain text formats such as CSV is [Parquet](https://parquet.apache.org/docs/overview/motivation/). The storage is by column (actually in chunks of columns). This works well with how datasets are often structured in that a given field/variable will generally have values of all the same type and there may be many repeated values, so there are opportunities for efficient storage including compression. Storage by column also allows retrieval only of the columns that a user needs. As a result data stored in the Parquet format often takes up much less space than stored as CSV and can be queried much faster. Also note that data stored in Parquet will often be stored as multiple files.\n\nHere's a brief exploration using a data file not in the class repository.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport time\n\n## Read from CSV\nt0 = time.time()\ndata_from_csv = pd.read_csv(os.path.join('..', 'data', 'airline.csv'))\nprint(time.time() - t0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.8881862163543701\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n## Write out Parquet-formatted data\ndata_from_csv.to_parquet(os.path.join('..', 'data', 'airline.parquet'))\n\n## Read from Parquet\nt0 = time.time()\ndata_from_parquet = pd.read_parquet(os.path.join(\n                                    '..', 'data', 'airline.parquet'))\nprint(time.time() - t0)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.10995340347290039\n```\n:::\n:::\n\n\nThe CSV file is 51 MB while the Parquet file is 8 MB.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nimport subprocess\nsubprocess.run([\"ls\", \"-l\", os.path.join(\"..\", \"data\", \"airline.csv\")])\nsubprocess.run([\"ls\", \"-l\", os.path.join(\"..\", \"data\", \"airline.parquet\")])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n-rw-r--r-- 1 paciorek scfstaff 51480244 Aug 29  2022 ../data/airline.csv\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nCompletedProcess(args=['ls', '-l', '../data/airline.csv'], returncode=0)\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n-rw-r--r-- 1 paciorek scfstaff 8153160 Aug 24 17:21 ../data/airline.parquet\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\nCompletedProcess(args=['ls', '-l', '../data/airline.parquet'], returncode=0)\n```\n:::\n:::\n\n\n# 2. Reading data from text files into Python\n\n## Core Python functions\n\nThe `read_table`  and `read_csv` functions in the Pandas package are  commonly used for reading\nin data. They read in delimited files (CSV specifically in the latter case).\nThe key arguments are the\ndelimiter (the `sep` argument) and whether the file contains a header, a\nline with the variable names. We can use `read_fwf()` to read from a\nfixed width text file into a data frame.\n\nThe most difficult part of reading in such files can be dealing with how\nPandas determines the types of the fields that are read in. While Pandas\nwill try to determine the types automatically, it can be safer (and faster)\nto tell Pandas what the types are, using the `dtype` argument to `read_table()`.\n\nLet's work through a couple examples. Before we do that, let's look at\nthe arguments to `read_table`. Note that `sep=''` can use regular expressions\n(which would be helpful if you want to separate on any amount of white space, as one example).\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndat = pd.read_table(os.path.join('..', 'data', 'RTADataSub.csv'),\n                    sep = ',', header = None)\ndat.dtypes.head()   # 'object' is string or mixed type\ndat.loc[0,1]     \ntype(dat.loc[0,1]) # string!\n## Whoops, there is an 'x', presumably indicating missingness:\ndat.loc[:,1].unique()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/usr/local/linux/mambaforge-3.11/lib/python3.11/site-packages/IPython/core/formatters.py:342: FutureWarning:\n\nIn future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=tex}\n\\begin{tabular}{ll}\n\\toprule\n{} &       0 \\\\\n\\midrule\n0 &  object \\\\\n1 &  object \\\\\n2 &  object \\\\\n3 &  object \\\\\n4 &  object \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n'2336'\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nstr\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\narray(['2336', '2124', '1830', '1833', '1600', '1578', '1187', '1005',\n       '918', '865', '871', '860', '883', '897', '898', '893', '913',\n       '870', '962', '880', '875', '884', '894', '836', '848', '885',\n       '851', '900', '861', '866', '867', '829', '853', '920', '877',\n       '908', '855', '845', '859', '856', '825', '828', '854', '847',\n       '840', '873', '822', '818', '838', '815', '813', '816', '849',\n       '802', '805', '792', '823', '808', '798', '800', '842', '809',\n       '807', '826', '810', '801', '794', '771', '796', '790', '787',\n       '775', '751', '783', '811', '768', '779', '795', '770', '821',\n       '830', '767', '772', '791', '781', '773', '777', '814', '778',\n       '782', '837', '759', '846', '797', '835', '832', '793', '803',\n       '834', '785', '831', '820', '812', '824', '728', '760', '762',\n       '753', '758', '764', '741', '709', '735', '749', '752', '761',\n       '750', '776', '766', '789', '763', '864', '858', '869', '886',\n       '844', '863', '916', '890', '872', '907', '926', '935', '933',\n       '906', '905', '912', '972', '996', '1009', '961', '952', '981',\n       '917', '1011', '1071', '1920', '3245', '3805', '3926', '3284',\n       '2700', '2347', '2078', '2935', '3040', '1860', '1437', '1512',\n       '1720', '1493', '1026', '928', '874', '833', '850', nan, 'x'],\n      dtype=object)\n```\n:::\n:::\n\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n## Let's treat 'x' as a missing value indicator.\ndat2 = pd.read_table(os.path.join('..', 'data', 'RTADataSub.csv'),\n                     sep = ',', header = None, na_values = 'x')\ndat2.dtypes.head()\ndat2.loc[:,1].unique()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/usr/local/linux/mambaforge-3.11/lib/python3.11/site-packages/IPython/core/formatters.py:342: FutureWarning:\n\nIn future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=tex}\n\\begin{tabular}{ll}\n\\toprule\n{} &        0 \\\\\n\\midrule\n0 &   object \\\\\n1 &  float64 \\\\\n2 &  float64 \\\\\n3 &  float64 \\\\\n4 &  float64 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\narray([2336., 2124., 1830., 1833., 1600., 1578., 1187., 1005.,  918.,\n        865.,  871.,  860.,  883.,  897.,  898.,  893.,  913.,  870.,\n        962.,  880.,  875.,  884.,  894.,  836.,  848.,  885.,  851.,\n        900.,  861.,  866.,  867.,  829.,  853.,  920.,  877.,  908.,\n        855.,  845.,  859.,  856.,  825.,  828.,  854.,  847.,  840.,\n        873.,  822.,  818.,  838.,  815.,  813.,  816.,  849.,  802.,\n        805.,  792.,  823.,  808.,  798.,  800.,  842.,  809.,  807.,\n        826.,  810.,  801.,  794.,  771.,  796.,  790.,  787.,  775.,\n        751.,  783.,  811.,  768.,  779.,  795.,  770.,  821.,  830.,\n        767.,  772.,  791.,  781.,  773.,  777.,  814.,  778.,  782.,\n        837.,  759.,  846.,  797.,  835.,  832.,  793.,  803.,  834.,\n        785.,  831.,  820.,  812.,  824.,  728.,  760.,  762.,  753.,\n        758.,  764.,  741.,  709.,  735.,  749.,  752.,  761.,  750.,\n        776.,  766.,  789.,  763.,  864.,  858.,  869.,  886.,  844.,\n        863.,  916.,  890.,  872.,  907.,  926.,  935.,  933.,  906.,\n        905.,  912.,  972.,  996., 1009.,  961.,  952.,  981.,  917.,\n       1011., 1071., 1920., 3245., 3805., 3926., 3284., 2700., 2347.,\n       2078., 2935., 3040., 1860., 1437., 1512., 1720., 1493., 1026.,\n        928.,  874.,  833.,  850.,   nan])\n```\n:::\n:::\n\n\nUsing `dtype` is a good way to control how data are read in.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndat = pd.read_table(os.path.join('..', 'data', 'hivSequ.csv'),\n                  sep = ',', header = 0,\n                  dtype = {\n                  'PatientID': int,\n                  'Resp': int,\n                  'PR Seq': str,\n                  'RT Seq': str,\n                  'VL-t0': float,\n                  'CD4-t0': int})\ndat.dtypes\ndat.loc[0,'PR Seq']\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/usr/local/linux/mambaforge-3.11/lib/python3.11/site-packages/IPython/core/formatters.py:342: FutureWarning:\n\nIn future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=tex}\n\\begin{tabular}{ll}\n\\toprule\n{} &        0 \\\\\n\\midrule\nPatientID &    int64 \\\\\nResp      &    int64 \\\\\nPR Seq    &   object \\\\\nRT Seq    &   object \\\\\nVL-t0     &  float64 \\\\\nCD4-t0    &    int64 \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n'CCTCAAATCACTCTTTGGCAACGACCCCTCGTCCCAATAAGGATAGGGGGGCAACTAAAGGAAGCYCTATTAGATACAGGAGCAGATGATACAGTATTAGAAGACATGGAGTTGCCAGGAAGATGGAAACCAAAAATGATAGGGGGAATTGGAGGTTTTATCAAAGTAARACAGTATGATCAGRTACCCATAGAAATCTATGGACATAAAGCTGTAGGTACAGTATTAATAGGACCTACACCTGTCAACATAATTGGAAGAAATCTGTTGACTCAGCTTGGTTGCACTTTAAATTTY'\n```\n:::\n:::\n\n\nNote that you can avoid reading in one or more columns by using the\n`usecols` argument. Also,\nspecifying the `dtype` argument explicitly should make for faster\nfile reading. \n\nIf possible, it's a good idea to look through the input file in the\nshell or in an editor before reading into Python to catch such issues in\nadvance. Using the UNIX command `less` on `RTADataSub.csv` would have revealed these\nvarious issues, but note that `RTADataSub.csv` is a 1000-line subset of\na much larger file of data available from the kaggle.com website. So\nmore sophisticated use of UNIX utilities (as we will see in Unit 3) is often\nuseful before trying to read something into a program.\n\nIf the file is not nicely arranged by field (e.g., if it has ragged\nlines), we'll need to do some more work. We can read each line\nas a separate string, after which we can process the\nlines using text manipulation. Here's an example from some US\nmeteorological data where I know from metadata (not provided here) that\nthe 4-11th values are an identifier, the 17-20th are the year, the\n22-23rd the month, etc.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nfile_path = os.path.join('..', 'data', 'precip.txt')\nwith open(file_path, 'r') as file:\n     lines = file.readlines()\n\nid = [line[3:11] for line in lines]\nyear = [int(line[17:21]) for line in lines]\nmonth = [int(line[21:23]) for line in lines]\nnvalues = [int(line[27:30]) for line in lines]\nyear[0:5]\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n[2010, 2010, 2010, 2010, 2010]\n```\n:::\n:::\n\n\nActually, that file, `precip.txt`, is in a fixed-width format (i.e.,\nevery element in a given column has the exact same number of\ncharacters),so reading in using `pandas.read_fwf()` would be a good strategy.\n\n\n\n## Connections and streaming\n\nPython allows you to read in not just from a file but from a more general\nconstruct called a *connection*. This can include reading in text from the output of running a shell command and from unzipping a file on the fly.\n\nHere are some examples of connections:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nimport gzip\nwith gzip.open('dat.csv.gz', 'r') as file:\n     lines = file.readlines()\n\nimport zipfile\nwith zipfile.ZipFile('dat.zip', 'r') as archive:\n     with archive.open('data.txt', 'r') as file:\n          lines = file.readlines()\n\nimport subprocess\ncommand = \"ls -al\"\noutput = subprocess.check_output(command, shell = True)\n# `output` is a sequence of bytes.\nwith io.BytesIO(output) as stream:  # Create a file-like object.\n    content = stream.readlines()\n\ndf = pd.read_csv(\"https://download.bls.gov/pub/time.series/cu/cu.item\", sep=\"\\t\")\n```\n:::\n\n\nIf a file is large, we may want to read it in in chunks (of lines), do\nsome computations to reduce the size of things, and iterate. This is referred\nto as online processing, streaming, or chunking, and can be done [using Pandas](https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-chunking) (among other tools).\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nfile_path = os.path.join('..', 'data', 'RTADataSub.csv')\nchunksize = 50 # Obviously this would be much larger in any real application.\n\nwith pd.read_csv(file_path, chunksize = chunksize) as reader:\n     for chunk in reader:\n         # manipulate the lines and store the key stuff\n         print(f'Read {len(chunk)} rows.')\n```\n:::\n\n\nMore details on sequential (on-line) processing of large files can be\nfound in the tutorial on large datasets mentioned in the reference list\nabove.\n\nOne cool trick that can come in handy is to 'read' from a string as if it were a text\nfile. Here's an example:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nfile_path = os.path.join('..', 'data', 'precip.txt')\nwith open(file_path, 'r') as file:\n     text = file.read()\n\nstringIOtext = io.StringIO(text)\ndf = pd.read_fwf(stringIOtext, header = None, widths = [3,8,4,2,4,2])\n```\n:::\n\n\nWe can create connections for writing output too. Just make sure to open\nthe connection first.\n\n## File paths\n\nA few notes on file paths, related to ideas of reproducibility.\n\n1.  In general, you don't want to hard-code absolute paths into your\n    code files because those absolute paths won't be available on the\n    machines of anyone you share the code with. Instead, use paths\n    relative to the directory the code file is in, or relative to a\n    baseline directory for the project, e.g.:\\\n\n\n    ::: {.cell execution_count=12}\n    ``` {.python .cell-code}\n    dat = pd.read_csv('../data/cpds.csv')\n    ```\n    :::\n    \n    \n2.  Using UNIX style directory separators will work in Windows, Mac or\n    Linux, but using Windows style separators is not portable across\n    operating systems.\n\n\n    ::: {.cell execution_count=13}\n    ``` {.python .cell-code}\n    ## good: will work on Windows\n    dat = pd.read_csv('../data/cpds.csv')\n    ## bad: won't work on Mac or Linux\n    dat = pd.read_csv('..\\data\\cpds.csv')  \n    ```\n    :::\n    \n    \n3.  Even better, use `os.path.join` so that paths are constructed\n    specifically for the operating system the user is using:\\\n\n\n    ::: {.cell execution_count=14}\n    ``` {.python .cell-code}\n    ## good: operating-system independent\n    dat = pd.read_csv(os.path.join('..', 'data', 'cpds.csv'))  \n    ```\n    :::\n    \n    \n## Reading data quickly: Arrow and Polars\n\nApache Arrow provides efficient data structures for working with data in memory, usable in Python via the PyArrow package. Data are stored by column, with values in a column stored sequentially and in such a way that one can access a specific value without reading the other values in the column (O(1) lookup). Arrow is designed to read data from various file formats, including Parquet, native Arrow format, and text files. In general Arrow will only read data from disk as needed, avoiding keeping the entire dataset in memory.\n\nOther options for avoiding reading all your data into memory include the Dask package and using `numpy.load` with the `mmap_mode` argument. \n\n`polars` is designed to be a faster alternative to Pandas for working with data in-memory. \n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nimport polars\nimport time\nt0 = time.time()\ndat = pd.read_csv(os.path.join('..', 'data', 'airline.csv'))\nt1 = time.time()\ndat2 = polars.read_csv(os.path.join('..', 'data', 'airline.csv'), null_values = ['NA'])\nt2 = time.time()\nprint(f\"Timing for Pandas: {t1-t0}.\")\nprint(f\"Timing for Polars: {t2-t1}.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTiming for Pandas: 0.8795554637908936.\nTiming for Polars: 0.19745445251464844.\n```\n:::\n:::\n\n\n# 3. Output from Python\n\n## Writing output to files\n\nFunctions for text output are generally analogous to those for input.\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nfile_path = os.path.join('/tmp', 'tmp.txt')\nwith open(file_path, 'w') as file:\n     file.writelines(lines)\n```\n:::\n\n\nWe can also use `file.write()` to write individual strings.\n\nIn Pandas, we can use `DataFrame.to_csv` and `DataFrame.to_parquet`.\n\nWe can use the `json.dump` function to output appropriate data objects\n(e.g., dictionaries or possibly lists) as JSON. One\nuse of JSON as output from Python would be to 'serialize' the information in\nan Python object such that it could be read into another program.\n\nAnd of course you can always save to a Pickle data file (a binary file format) using\n`pickle.dump()` and `pickle.load()` from the `pickle` package.\nHappily this is platform-independent so can be used to transfer\nPython objects between different OS.\n\n\n## Formatting output\n\nWe can use [string formatting](https://docs.python.org/3/library/string.html#formatstrings) to control how output is printed to the screen.\n\nThe mini-language involved in the format specification can get fairly involved,\nbut a few basic pieces of syntax can do most of what one generally needs to do.\n\nWe can format numbers to chosen number of digits and decimal places\nand handle alignment, using the `format` method of the string class.\n\nFor example:\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\n'{:>10}'.format(3.5)    # right-aligned, using 10 characters\n'{:.10f}'.format(1/3)   # force 10 decimal places\n'{:15.10f}'.format(1/3) # force 15 characters, with 10 decimal places\nformat(1/3, '15.10f') # alternative using a function\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n'       3.5'\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n'0.3333333333'\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n'   0.3333333333'\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\n'   0.3333333333'\n```\n:::\n:::\n\n\nWe can also \"interpolate\" variables into strings.\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n\"The number pi is {}.\".format(np.pi)\n\"The number pi is {:.5f}.\".format(np.pi)\n\"The number pi is {:.12f}.\".format(np.pi)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n'The number pi is 3.141592653589793.'\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n'The number pi is 3.14159.'\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\n'The number pi is 3.141592653590.'\n```\n:::\n:::\n\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nval1 = 1.5\nval2 = 2.5\n# As of Python 3.6, put the variable names in directly.\nprint(f\"Let's add {val1} and {val2}.\")  \nnum1 = 1/3\nprint(\"Let's add the %s numbers %.5f and %15.7f.\"\n       %('floating point', num1 ,32+1/7))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLet's add 1.5 and 2.5.\nLet's add the floating point numbers 0.33333 and      32.1428571.\n```\n:::\n:::\n\n\nOr to insert into a file:\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nfile_path = os.path.join('/tmp', 'tmp.txt')\nwith open(file_path, 'a') as file:\n     file.write(\"Let's add the %s numbers %.5f and %15.7f.\"\n                %('floating point', num1 ,32+1/7))\n```\n:::\n\n\n`round` is another option, but it's often better to directly control the printing format.\n\n\n# 4. Webscraping and working with HTML, XML, and JSON\n\nThe book *XML and Web Technologies for Data Sciences with R* by Deb\nNolan (UCB Stats faculty) and Duncan Temple Lang (UCB Stats PhD alumnus\nand UC Davis Stats faculty) provides extensive information about getting\nand processing data off of the web, including interacting with web\nservices such as REST and SOAP and programmatically handling\nauthentication.\n\nHere are some UNIX command-line tools to help in webscraping and working\nwith files in formats such as JSON, XML, and HTML:\n<http://jeroenjanssens.com/2013/09/19/seven-command-line-tools-for-data-science.html>.\n\nWe'll cover a few basic examples in this section, but HTML and XML\nformatting and navigating the structure of such pages in great detail is\nbeyond the scope of what we can cover. The key thing is to see the main\nconcepts and know that the tools exist so that you can learn how to use\nthem if faced with such formats.\n\n## Reading HTML\n\nHTML (Hypertext Markup Language) is the standard markup language used\nfor displaying content in a web browser. In simple webpages (ignoring\nthe more complicated pages that involve Javascript), what you see in\nyour browser is simply a *rendering* (by the browser) of a text file containing HTML.\n\nHowever, instead of rendering the HTML in a browser, we might want to\nuse code to extract information from the HTML.\n\nLet's see a brief example of reading in HTML tables.\n\nNote that before doing any coding, it can be helpful to look at the raw\nHTML source code for a given page. We can explore the underlying HTML\nsource in advance of writing our code by looking at the page source\ndirectly in the browser (e.g., in Firefox under the 3-lines (hamburger) \"open menu\"\nsymbol, see `Web Developer (or More Tools) -> Page Source` and in Chrome\n`View -> Developer -> View Source`), or by downloading the webpage and\nlooking at it in an editor, although in some cases (such as the\nnytimes.com case), what we might see is a lot of JavaScript.\n\nOne lesson here is not to write a lot of your own code to do something\nthat someone else has probably already written a package for. We'll use\nthe `BeautifulSoup4` package.\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nimport requests\nfrom bs4 import BeautifulSoup as bs\n\nURL = \"https://en.wikipedia.org/wiki/List_of_countries_and_dependencies_by_population\"\nresponse = requests.get(URL)\nhtml = response.content\n\n# Create a BeautifulSoup object to parse the HTML\nsoup = bs(html, 'html.parser')\n\nhtml_tables = soup.find_all('table')\n\npd_tables = [pd.read_html(str(tbl))[0] for tbl in html_tables]\n\n[x.shape[0] for x in pd_tables]\n\npd_tables[0].head()\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\n[242, 13, 1]\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n/usr/local/linux/mambaforge-3.11/lib/python3.11/site-packages/IPython/core/formatters.py:342: FutureWarning:\n\nIn future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=14}\n```{=tex}\n\\begin{tabular}{lllrllll}\n\\toprule\n{} & Unnamed: 0 & Country / Dependency &  Population & \\% of world &         Date & Source (official or from the United Nations) & Unnamed: 6 \\\\\n\\midrule\n0 &          – &                World &  8055874000 &       100\\% &  24 Aug 2023 &                             UN projection[3] &        NaN \\\\\n1 &          1 &                China &  1411750000 &        NaN &  31 Dec 2022 &                         Official estimate[4] &        [b] \\\\\n2 &          2 &                India &  1392329000 &        NaN &   1 Jul 2023 &                       Official projection[5] &        [c] \\\\\n3 &          3 &        United States &   335300000 &        NaN &  24 Aug 2023 &                 National population clock[7] &        [d] \\\\\n4 &          4 &            Indonesia &   277749853 &        NaN &  31 Dec 2022 &                         Official estimate[8] &        NaN \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nBeautiful Soup works by reading in the HTML as text and then parsing it\nto build up a tree containing the HTML elements. Then one can [search by\nHTML tag or attribute](https://beautiful-soup-4.readthedocs.io/en/latest/#searching-the-tree)\nfor information you want using `find_all`.\n\nAs another example, it's often useful to be able to extract the hyperlinks in an HTML document. \n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nURL = \"http://www1.ncdc.noaa.gov/pub/data/ghcn/daily/by_year\"\nresponse = requests.get(URL)\nsoup = bs(response.content, 'html.parser')\n\n## Approach 1: search for HTML 'a' tags.\na_elements = soup.find_all('a')\nlinks1 = [x.get('href') for x in a_elements]\n## Approach 2: search for 'a' elements with 'href' attribute\nhref_elements = soup.find_all('a', href = True)\nlinks2 = [x.get('href') for x in href_elements]\n## In either case, then use `get` to retrieve the `href` attribute value.\n\nlinks2[0:9]\n# help(bs.find_all)\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\n['?C=N;O=D',\n '?C=M;O=A',\n '?C=S;O=A',\n '?C=D;O=A',\n '/pub/data/ghcn/daily/',\n '1750.csv.gz',\n '1763.csv.gz',\n '1764.csv.gz',\n '1765.csv.gz']\n```\n:::\n:::\n\n\nThe `kwargs` keyword arguments to `find` and `find_all` allow one\nto search for elements with particular characteristics, such\nas having a particular attribute (seen above) or having an attribute\nhave a particular value (e.g., picking out an element with a particular\n`id`).\n\nHere's another example of extracting specific components of information\nfrom a webpage (results not shown, since headlines will vary from day to\nday). We'll use `get_text` to retrieve the element's value.\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nURL = \"https://www.nytimes.com\"\nresponseNYT = requests.get(URL)\nsoupNYT = bs(responseNYT.content, 'html.parser')\nh2_elements = soupNYT.find_all(\"h2\")\nheadlines2 = [x.get_text() for x in h2_elements]\nh3_elements = soupNYT.find_all(\"h3\")\nheadlines3 = [x.get_text() for x in h3_elements]\n```\n:::\n\n\nMore generally, we may want to read an HTML document, parse it into its\ncomponents (i.e., the HTML elements), and navigate through the tree\nstructure of the HTML.\n\nWe can use [CSS selectors](https://www.w3schools.com/cssref/css_selectors.asp)\n with the `select` method for more powerful extraction capabilities. Going back to the climate data, let's extract all the `th` elements nested within `tr` elements:\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nsoup.select(\"tr th\")\n## Or the `a` elements whose parents are `th` elements:\nsoup.select(\"th > a\")\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n[<th><a href=\"?C=N;O=D\">Name</a></th>,\n <th><a href=\"?C=M;O=A\">Last modified</a></th>,\n <th><a href=\"?C=S;O=A\">Size</a></th>,\n <th><a href=\"?C=D;O=A\">Description</a></th>,\n <th colspan=\"4\"><hr/></th>,\n <th colspan=\"4\"><hr/></th>]\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n[<a href=\"?C=N;O=D\">Name</a>,\n <a href=\"?C=M;O=A\">Last modified</a>,\n <a href=\"?C=S;O=A\">Size</a>,\n <a href=\"?C=D;O=A\">Description</a>]\n```\n:::\n:::\n\n\nNext let's use the *XPath* language to specify\nelements rather than CSS selectors. XPath can also be used for\nnavigating through XML documents.\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nimport lxml.html\n\n# Convert the BeautifulSoup object to a lxml object\nlxml_doc = lxml.html.fromstring(str(soup))\n\n# Use XPath to select elements\na_elements = lxml_doc.xpath('//a[@href]')\nlinks = [x.get('href') for x in a_elements]\nlinks[0:9]\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\n['?C=N;O=D',\n '?C=M;O=A',\n '?C=S;O=A',\n '?C=D;O=A',\n '/pub/data/ghcn/daily/',\n '1750.csv.gz',\n '1763.csv.gz',\n '1764.csv.gz',\n '1765.csv.gz']\n```\n:::\n:::\n\n\n## XML\n\nXML is a markup language used to store data in self-describing (no\nmetadata needed) format, often with a hierarchical structure. It\nconsists of sets of elements (also known as nodes because they generally\noccur in a hierarchical structure and therefore have parents, children,\netc.) with tags that identify/name the elements, with some similarity to\nHTML. Some examples of the use of XML include serving as the underlying\nformat for Microsoft Office and Google Docs documents and for the KML\nlanguage used for spatial information in Google Earth.\n\nHere's a brief example. The book with id attribute `bk101` is an\nelement; the author of the book is also an element that is a child\nelement of the book. The id attribute allows us to uniquely identify the\nelement.\n\n```\n    <?xml version=\"1.0\"?>\n    <catalog>\n       <book id=\"bk101\">\n          <author>Gambardella, Matthew</author>\n          <title>XML Developer's Guide</title>\n          <genre>Computer</genre>\n          <price>44.95</price>\n          <publish_date>2000-10-01</publish_date>\n          <description>An in-depth look at creating applications with XML.</description>\n       </book>\n       <book id=\"bk102\">\n          <author>Ralls, Kim</author>\n          <title>Midnight Rain</title>\n          <genre>Fantasy</genre>\n          <price>5.95</price>\n          <publish_date>2000-12-16</publish_date>\n         <description>A former architect battles corporate zombies, an evil sorceress, and her own childhood to become queen of the world.</description>\n       </book>\n    </catalog>\n```\n\nWe can read XML documents into Python using various packages,\nincluding `lxml` and then manipulate the resulting structured data\nobject. Here's an\nexample of working with lending data from the Kiva lending non-profit.\nYou can see the XML format in a browser at <http://api.kivaws.org/v1/loans/newest.xml>.\n\nXML documents have a tree structure with information at nodes. As above\nwith HTML, one can use the *XPath* language for navigating the tree and\nfinding and extracting information from the node(s) of interest.\n\nHere is some example code for extracting loan info from the Kiva data.\nWe'll first show the 'brute force' approach of working with the data as a\nlist and then the better approach of using XPath.\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nimport xmltodict\n\nURL = \"https://api.kivaws.org/v1/loans/newest.xml\"\nresponse = requests.get(URL)\ndata = xmltodict.parse(response.content)\ndata.keys()\ndata['response'].keys()\ndata['response']['loans'].keys()\nlen(data['response']['loans']['loan'])\ndata['response']['loans']['loan'][2]\ndata['response']['loans']['loan'][2]['activity']\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\ndict_keys(['response'])\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\ndict_keys(['paging', 'loans'])\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\ndict_keys(['@type', 'loan'])\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n20\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n{'id': '2627907',\n 'name': 'María Luisa',\n 'description': {'languages': {'@type': 'list', 'language': ['es', 'en']}},\n 'status': 'fundraising',\n 'funded_amount': '0',\n 'basket_amount': '0',\n 'image': {'id': '5240922', 'template_id': '1'},\n 'activity': 'Fish Selling',\n 'sector': 'Food',\n 'themes': {'@type': 'list', 'theme': 'Vulnerable Groups'},\n 'use': 'to buy dried fish, shrimp, and more seafood products in order to be able to cover the demand in her business.',\n 'location': {'country_code': 'SV',\n  'country': 'El Salvador',\n  'town': 'La Unión',\n  'geo': {'level': 'town', 'pairs': '13.332346 -87.850064', 'type': 'point'}},\n 'partner_id': '199',\n 'posted_date': '2023-08-25T00:00:12Z',\n 'planned_expiration_date': '2023-09-29T00:00:12Z',\n 'loan_amount': '1000',\n 'borrower_count': '1',\n 'lender_count': '0',\n 'bonus_credit_eligibility': '1',\n 'tags': {'@type': 'list',\n  'tag': [{'name': '#Woman-Owned Business', 'id': '6'},\n   {'name': '#Animals', 'id': '11'},\n   {'name': '#Parent', 'id': '16'}]}}\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\n'Fish Selling'\n```\n:::\n:::\n\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nfrom lxml import etree\ndoc = etree.fromstring(response.content)\n\nloans = doc.xpath(\"//loan\")\n[loan.xpath(\"activity/text()\") for loan in loans]\n\n## suppose we only want the country locations of the loans (using XPath)\n[loan.xpath(\"location/country/text()\") for loan in loans]\n## or extract the geographic coordinates\n[loan.xpath(\"location/geo/pairs/text()\") for loan in loans]\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n[['Crafts'],\n ['Food'],\n ['Fish Selling'],\n ['Cereals'],\n ['Fish Selling'],\n ['Farming'],\n ['Personal Housing Expenses'],\n ['General Store'],\n ['Personal Housing Expenses'],\n ['Pigs'],\n ['Farming'],\n ['Fish Selling'],\n ['Construction'],\n ['Sewing'],\n ['Bricks'],\n ['Grocery Store'],\n ['Retail'],\n ['Pigs'],\n ['Poultry'],\n ['Catering']]\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n[['Tonga'],\n ['Indonesia'],\n ['El Salvador'],\n ['Philippines'],\n ['El Salvador'],\n ['El Salvador'],\n ['Philippines'],\n ['Philippines'],\n ['Philippines'],\n ['Philippines'],\n ['Ecuador'],\n ['Philippines'],\n ['El Salvador'],\n ['Uganda'],\n ['Madagascar'],\n ['Madagascar'],\n ['El Salvador'],\n ['Ecuador'],\n ['Madagascar'],\n ['Honduras']]\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n[['-21.141349 -175.186229'],\n ['-6.110366 106.163975'],\n ['13.332346 -87.850064'],\n ['10.292561 123.024652'],\n ['13.833333 -88.916667'],\n ['13.833333 -88.916667'],\n ['10.878345 123.408176'],\n ['10.292561 123.024652'],\n ['11.572299 122.770544'],\n ['10.960102 123.941552'],\n ['0.594895 -77.828151'],\n ['10.878345 123.408176'],\n ['13.332346 -87.850064'],\n ['3.652738 31.728096'],\n ['-18.87919 47.507906'],\n ['-18.87919 47.507906'],\n ['13.836337 -88.850303'],\n ['0.594895 -77.828151'],\n ['-18.87919 47.507906'],\n ['15.669628 -87.14229']]\n```\n:::\n:::\n\n\n## JSON\n\nJSON files are structured as \"attribute-value\" pairs (aka \"key-value\"\npairs), often with a hierarchical structure. Here's a brief example:\n\n```\n    {\n      \"firstName\": \"John\",\n      \"lastName\": \"Smith\",\n      \"isAlive\": true,\n      \"age\": 25,\n      \"address\": {\n        \"streetAddress\": \"21 2nd Street\",\n        \"city\": \"New York\",\n        \"state\": \"NY\",\n        \"postalCode\": \"10021-3100\"\n      },\n      \"phoneNumbers\": [\n        {\n          \"type\": \"home\",\n          \"number\": \"212 555-1234\"\n        },\n        {\n          \"type\": \"office\",\n          \"number\": \"646 555-4567\"\n        }\n      ],\n      \"children\": [],\n      \"spouse\": null\n    }\n```\n\nA set of key-value pairs is a named array and is placed inside braces\n(squiggly brackets). Note the nestedness of arrays within arrays (e.g.,\naddress within the overarching person array and the use of square\nbrackets for unnamed arrays (i.e., vectors of information), as well as\nthe use of different types: character strings, numbers, null, and (not\nshown) boolean/logical values. JSON and XML can be used in similar ways,\nbut JSON is less *verbose* than XML.\n\nWe can read JSON into Python using the `json` package.\nLet's play again with the Kiva data. The same data that we had worked\nwith in XML format is also available in JSON format: <https://api.kivaws.org/v1/loans/newest.json>.\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\nURL = \"https://api.kivaws.org/v1/loans/newest.json\"\nresponse = requests.get(URL)\n\nimport json\ndata = json.loads(response.text)\ntype(data)\ndata.keys()\n\ntype(data['loans'])\ndata['loans'][0].keys()\n\ndata['loans'][0]['location']['country']\n[loan['location']['country']  for loan in data['loans']]\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\ndict\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\ndict_keys(['paging', 'loans'])\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\nlist\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\ndict_keys(['id', 'name', 'description', 'status', 'funded_amount', 'basket_amount', 'image', 'activity', 'sector', 'themes', 'use', 'location', 'partner_id', 'posted_date', 'planned_expiration_date', 'loan_amount', 'borrower_count', 'lender_count', 'bonus_credit_eligibility', 'tags'])\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n'Tonga'\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n['Tonga',\n 'Indonesia',\n 'El Salvador',\n 'Philippines',\n 'El Salvador',\n 'El Salvador',\n 'Philippines',\n 'Philippines',\n 'Philippines',\n 'Philippines',\n 'Ecuador',\n 'Philippines',\n 'El Salvador',\n 'Uganda',\n 'Madagascar',\n 'Madagascar',\n 'El Salvador',\n 'Ecuador',\n 'Madagascar',\n 'Honduras']\n```\n:::\n:::\n\n\nOne disadvantage of JSON is that it is not set up to deal with missing\nvalues, infinity, etc.\n\n## Webscraping and web APIs\n\nHere we'll see some examples of making requests over the Web to get\ndata. We'll use APIs to systematically query a website for information.\nIdeally, but not always, the API will be documented. In many cases that\nsimply amounts to making an HTTP GET request, which is done by\nconstructing a URL.\n\nThe `requests` package is  useful for a wide variety of such\nfunctionality. Note that much of the functionality I describe below is\nalso possible within the shell using either `wget` or `curl`.\n\n### Webscraping ethics and best practices\n\nWebscraping is the process of extracting data from the web, either\ndirectly from a website or using a web API (application programming\ninterface).\n\n1.  **Should you webscrape?** In general, if we can avoid webscraping\n    (particularly if there is not an API) and instead directly download\n    a data file from a website, that is greatly preferred.\n\n2.  **May you webscrape?** Before you set up any automated downloading\n    of materials/data from the web you should make sure that what you\n    are about to do is consistent with the rules provided by the\n    website.\n\nSome places to look for information on what the website allows are:\n\n-   legal pages such as Terms of Service or Terms and Conditions on the\n    website.\n\n-   check the robots.txt file (e.g.,\n    <https://scholar.google.com/robots.txt>) to see what a web crawler\n    is allowed to do, and whether the site requires a particular delay\n    between requests to the sites\n\n-   potentially contact the site owner if you plan to scrape a large\n    amount of data\n\nHere are some links with useful information:\n\n-   [Blog post on webscraping\n    ethics](https://towardsdatascience.com/ethics-in-web-scraping-b96b18136f01)\n\n-   [Some information on how to understand a robots.txt\n    file](https://www.promptcloud.com/blog/how-to-read-and-respect-robots-file)\n\nTips for when you make automated requests:\n\n- When debugging code that processes the result of such a request, just run the request once, save (i.e., cache) the result, and then work on the processing code applied to the result. Don't make the same request over and over again.\n- In many cases you will want to include a time delay between your\nautomated requests to a site, including if you are not actually crawling\na site but just want to automate a small number of queries.\n\n### What is HTTP?\n\nHTTP (hypertext transfer protocol) is a system for communicating\ninformation from a server (i.e., the website of interest) to a client\n(e.g., your laptop). The client sends a request and the server sends a\nresponse.\n\nWhen you go to a website in a browser, your browser makes an HTTP GET\nrequest to the website. Similarly, when we did some downloading of html\nfrom webpages above, we used an HTTP GET request.\n\nAnytime the URL you enter includes parameter information after a question mark\n(`www.somewebsite.com?param1=arg1&param2=arg2`), you are using an API.\n\nThe response to an HTTP request will include a status code, which can be\ninterpreted based on [this\ninformation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).\n\nThe response will generally contain content in the form of text (e.g.,\nHTML, XML, JSON) or raw bytes.\n\n### APIs: REST- and SOAP-based web services\n\nIdeally a web service documents their API (Applications Programming\nInterface) that serves data or allows other interactions. REST and SOAP\nare popular API standards/styles. Both REST and SOAP use HTTP requests;\nwe'll focus on REST as it is more common and simpler. When using REST, we access *resources*, which might be a Facebook\naccount or a database of stock quotes. The API will\n(hopefully) document what information it expects from the user and will\nreturn the result in a standard format (often a particular file format\nrather than producing a webpage).\n\nOften the format of the request is a URL (aka an endpoint) plus a query\nstring, passed as a GET request. Let's search for plumbers near\nBerkeley, and we'll see the GET request, in the form:\n\n<https://www.yelp.com/search?find_desc=plumbers&find_loc=Berkeley+CA&ns=1>\n\n-   the query string begins with ?\n\n-   there are one or more `Parameter=Argument` pairs\n\n-   pairs are separated by &\n\n-   \\+ is used in place of each space\n\n\nLet's see an example of accessing economic data from the\nWorld Bank, using the [documentation for their API](https://datahelpdesk.worldbank.org/knowledgebase/topics/125589-developer-information). Following the [API call structure](https://datahelpdesk.worldbank.org/knowledgebase/articles/898581-api-basic-call-structures), we can download (for example), data on various countries. The documentation indicates that our REST-based query can use either a URL structure or an argument-based structure.\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n## Queries based on the documentation\napi_url = \"http://api.worldbank.org/V2/incomeLevel/LIC/country\"\napi_args = \"http://api.worldbank.org/V2/country?incomeLevel=LIC\"\n\n## Generalizing a bit\nurl = \"http://api.worldbank.org/V2/country?incomeLevel=MIC&format=json\"\nresponse = requests.get(url)\n\n# data = json.loads(response.content)\n# TODO: debug why above line fails when rendering\n\n## Be careful of data truncation/pagination\nif False:\n    url = \"http://api.worldbank.org/V2/country?incomeLevel=MIC&format=json&per_page=1000\"\n    response = requests.get(url)\n    data = json.loads(response.content)\n\n## Programmatic control\nbaseURL = \"http://api.worldbank.org/V2/country\"\ngroup = 'MIC'\nformat = 'json'\nargs = {'incomeLevel': group, 'format': format, 'per_page': 1000}\nurl = baseURL + '?' + '&'.join(['='.join(\n                               [key, str(args[key])]) for key in args])\nresponse = requests.get(url)\ndata = json.loads(response.content)\n   \ntype(data)\nlen(data[1])\ntype(data[1][5])\ndata[1][5]\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\nlist\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n108\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\ndict\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\n{'id': 'BEN',\n 'iso2Code': 'BJ',\n 'name': 'Benin',\n 'region': {'id': 'SSF', 'iso2code': 'ZG', 'value': 'Sub-Saharan Africa '},\n 'adminregion': {'id': 'SSA',\n  'iso2code': 'ZF',\n  'value': 'Sub-Saharan Africa (excluding high income)'},\n 'incomeLevel': {'id': 'LMC',\n  'iso2code': 'XN',\n  'value': 'Lower middle income'},\n 'lendingType': {'id': 'IDX', 'iso2code': 'XI', 'value': 'IDA'},\n 'capitalCity': 'Porto-Novo',\n 'longitude': '2.6323',\n 'latitude': '6.4779'}\n```\n:::\n:::\n\n\nAPIs can change and disappear. A few years ago, the example above involved the World Bank's Climate Data API, which I can no longer find!\n\n\nAs another example, here we can see the [US Treasury Department API](https://fiscaldata.treasury.gov/api-documentation/), which allows us to construct queries for federal financial data.\n\nThe Nolan and Temple Lang book provides a number of examples of\ndifferent ways of authenticating with web services that control access\nto the service.\n\nFinally, some web services allow us to pass information to the service\nin addition to just getting data or information. E.g., you can\nprogrammatically interact with your Facebook, Dropbox, and Google Drive\naccounts using REST based on HTTP POST, PUT, and DELETE requests.\nAuthentication is of course important in these contexts and some times\nyou would first authenticate with your login and password and receive a\n\"token\". This token would then be used in subsequent interactions in the\nsame session.\n\nI created your `github.berkeley.edu` accounts from Python by interacting\nwith the [GitHub API](https://docs.github.com/en/rest/reference/repos)\nusing `requests`.\n\n### HTTP requests by deconstructing an (undocumented) API\n\nIn some cases an API may not be documented or we might be lazy and not\nuse the documentation. Instead we might deconstruct the queries a\nbrowser makes and then mimic that behavior, in some cases having to\nparse HTML output to get at data. Note that if the webpage changes even\na little bit, our carefully constructed query syntax may fail.\n\nLet's look at some UN data (agricultural crop data). By going to\\\n<http://data.un.org/Explorer.aspx?d=FAO>, and clicking on \"Crops\", we'll\nsee a bunch of agricultural products with \"View data\" links. Click on\n\"apricots\" as an example and you'll see a \"Download\" button that allows\nyou to download a CSV of the data. Let's select a range of years and\nthen try to download \"by hand\". Sometimes we can right-click on the link\nthat will download the data and directly see the URL that is being\naccessed and then one can deconstruct it so that you can create URLs\nprogrammatically to download the data you want.\n\nIn this case, we can't see the full URL that is being used because\nthere's some Javascript involved. Therefore, rather than looking at the\nURL associated with a link we need to view the actual HTTP request sent\nby our browser to the server. We can do this using features of the\nbrowser (e.g., in Firefox see `Web Developer -> Network` and in Chrome\n`View -> Developer -> Developer tools` and choose the `Network` tab) (or right-click on the\nwebpage and select `Inspect` and then `Network`). Based on this we can\nsee that an HTTP GET request is being used with a URL such as:\\\n<http://data.un.org/Handlers/DownloadHandler.ashx?DataFilter=itemCode:526;year:2012,2013,2014,2015,2016,2017&DataMartId=FAO&Format=csv&c=2,4,5,6,7&s=countryName:asc,elementCode:asc,year:desc>.\n\nWe'e now able to easily download the data using that URL, which we can\nfairly easily construct using string processing in bash, Python, or R,\nsuch as this (here I just paste it together directly, but using more structured syntax\nsuch as I used for the World Bank example would be better):\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\nimport zipfile\n\n## example URL:\n## http://data.un.org/Handlers/DownloadHandler.ashx?DataFilter=itemCode:526;\n##year:2012,2013,2014,2015,2016,2017&DataMartId=FAO&Format=csv&c=2,4,5,6,7&\n##s=countryName:asc,elementCode:asc,year:desc\nitemCode = 526\nbaseURL = \"http://data.un.org/Handlers/DownloadHandler.ashx\"\nyrs = ','.join([str(yr) for yr in range(2012,2018)])\nfilter = f\"?DataFilter=itemCode:{itemCode};year:{yrs}\"\nargs1 = \"&DataMartId=FAO&Format=csv&c=2,3,4,5,6,7&\"\nargs2 = \"s=countryName:asc,elementCode:asc,year:desc\"\nurl = baseURL + filter + args1 + args2\n## If the website provided a CSV, this would be easier, but it zips the file.\nresponse = requests.get(url)\n\nwith io.BytesIO(response.content) as stream:  # create a file-like object\n     with zipfile.ZipFile(stream, 'r') as archive:   # treat the object as a zip file\n          with archive.open(archive.filelist[0].filename, 'r') as file:  # get a pointer to the embedded file\n              dat = pd.read_csv(file)\n\ndat.head()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/usr/local/linux/mambaforge-3.11/lib/python3.11/site-packages/IPython/core/formatters.py:342: FutureWarning:\n\nIn future versions `DataFrame.to_latex` is expected to utilise the base implementation of `Styler.to_latex` for formatting and rendering. The arguments signature may therefore change. It is recommended instead to use `DataFrame.style.to_latex` which also contains additional functionality.\n\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=22}\n```{=tex}\n\\begin{tabular}{llllrlrl}\n\\toprule\n{} & Country or Area & Element Code &                                          Element &    Year &   Unit &   Value & Value Footnotes \\\\\n\\midrule\n0 &     Afghanistan &          432 &  Gross Production Index Number (2014-2016 = 100) &  2017.0 &  index &  202.19 &              Fc \\\\\n1 &     Afghanistan &          432 &  Gross Production Index Number (2014-2016 = 100) &  2016.0 &  index &   27.45 &              Fc \\\\\n2 &     Afghanistan &          432 &  Gross Production Index Number (2014-2016 = 100) &  2015.0 &  index &  134.50 &              Fc \\\\\n3 &     Afghanistan &          432 &  Gross Production Index Number (2014-2016 = 100) &  2014.0 &  index &  138.05 &              Fc \\\\\n4 &     Afghanistan &          432 &  Gross Production Index Number (2014-2016 = 100) &  2013.0 &  index &  138.05 &              Fc \\\\\n\\bottomrule\n\\end{tabular}\n```\n:::\n:::\n\n\nSo, what have we achieved?\n\n1. We have a reproducible workflow we can share with others (perhaps ourself in the future).\n\n2. We can automate the process of downloading many such files.\n\n\n### More details on HTTP requests\n\nA more sophisticated way to do the download is to pass the request in a structured way with named input parameters. This request is easier to construct programmatically. Here what is returned is a zip file, which is represented in Python as a sequence of “raw” bytes. \n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\ndata = {\"DataFilter\": f\"itemCode:{itemCode};year:{yrs}\",\n       \"DataMartID\": \"FAO\", \n       \"Format\": \"csv\", \n       \"c\": \"2,3,4,5,6,7\",\n       \"s\": \"countryName:asc,elementCode:asc,year:desc\"\n       }    \n\nresponse = requests.get(baseURL, params = data)\n\nwith io.BytesIO(response.content) as stream:  \n     with zipfile.ZipFile(stream, 'r') as archive:\n          with archive.open(archive.filelist[0].filename, 'r') as file:  \n              dat = pd.read_csv(file)\n\n```\n:::\n\n\nIn some cases we may need to send a lot of information as part of the\nURL in a GET request. If it gets to be too long (e.g,, more than 2048\ncharacters) many web servers will reject the request. Instead we may\nneed to use an HTTP POST request (POST requests are often used for\nsubmitting web forms). A typical request would have syntax like this\nsearch (using `requests`):\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nurl = 'http://www.wormbase.org/db/searches/advanced/dumper'\n\ndata = {      \"specipes\":\"briggsae\",\n              \"list\": \"\",\n              \"flank3\": \"0\",\n              \"flank5\": \"0\",\n              \"feature\": \"Gene Models\",\n              \"dump\": \"Plain TEXT\",\n              \"orientation\": \"Relative to feature\",\n              \"relative\": \"Chromsome\",\n              \"DNA\":\"flanking sequences only\",\n              \".cgifields\" :  \"feature, orientation, DNA, dump, relative\"\n}                                  \n\nresponse = requests.post(url, data = data)\nif response.status_code == 200:\n    print(\"POST request successful\")\nelse:\n    print(f\"POST request failed with status code: {response.status_code}\")\n```\n:::\n\n\nUnfortunately that specific search doesn't work because the server URL\nand/or API seem to have changed. But it gives you an idea of what the\nformat would look like.\n\n`requests` can handle other kinds of HTTP requests such as PUT\nand DELETE. Finally, some websites use cookies to keep track of users,\nand you may need to download a cookie in the first interaction with the\nHTTP server and then send that cookie with later interactions. More\ndetails are available in the Nolan and Temple Lang book.\n\n### Packaged access to an API\n\nFor popular websites/data sources, a developer may have packaged up the\nAPI calls in a user-friendly fashion for use from Python, R, or other\nsoftware. For example there are Python (twitter) and R (twitteR)\npackages for interfacing with Twitter via its API.\n\nHere's some example code for Python. This looks up the US senators'\nTwitter names and then downloads a portion of each of their timelines,\ni.e., the time series of their tweets. Note that Twitter has limits on\nhow much one can download at once.\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\nimport json\nimport twitter\n\n# You will need to set the following variables with your\n# personal information.  To do this you will need to create\n# a personal account on Twitter (if you don't already have\n# one).  Once you've created an account, create a new\n# application here:\n#    https://dev.twitter.com/apps\n#\n# You can manage your applications here:\n#    https://apps.twitter.com/\n#\n# Select your application and then under the section labeled\n# \"Key and Access Tokens\", you will find the information needed\n# below.  Keep this information private.\nCONSUMER_KEY       = \"\"\nCONSUMER_SECRET    = \"\"\nOAUTH_TOKEN        = \"\"\nOAUTH_TOKEN_SECRET = \"\"\n\nauth = twitter.oauth.OAuth(OAUTH_TOKEN, OAUTH_TOKEN_SECRET,\n                           CONSUMER_KEY, CONSUMER_SECRET)\napi = twitter.Twitter(auth=auth)\n\n# get the list of senators\nsenators = api.lists.members(owner_screen_name=\"gov\",\n                             slug=\"us-senate\", count=100)\n\n# get all the senators' timelines\nnames = [d[\"screen_name\"] for d in senators[\"users\"]]\ntimelines = [api.statuses.user_timeline(screen_name=name, count = 500) \n             for name in names]\n\n# save information out to JSON\nwith open(\"senators-list.json\", \"w\") as f:\n    json.dump(senators, f, indent=4, sort_keys=True)\nwith open(\"timelines.json\", \"w\") as f:\n    json.dump(timelines, f, indent=4, sort_keys=True)\n```\n:::\n\n\n### Accessing dynamic pages\n\nSome websites dynamically change in reaction to the user behavior. In\nthese cases you need a tool that can mimic the behavior of a human\ninteracting with a site. Some options are:\n\n- `selenium` is a popular tool for doing this, and there is a Python package of the same name.\n- Using `scrapy` plus `splash`  is another approach.\n\n# 5. File and string encodings\n\nText (either in the form of a file with regular language in it or a data\nfile with fields of character strings) will often contain characters\nthat are not part of the [limited ASCII set of\ncharacters](http://en.wikipedia.org/wiki/ASCII), which has $2^{7}=128$\ncharacters and control codes; basically what you see on a standard US\nkeyboard. Each character takes up one byte (8 bits) of space (there is\nan unused bit that comes in handy in the UTF-8 context). We can actually\nhand-generate an ASCII file using the binary representation of each\ncharacter in Python as an illustration.\n\nThe letter \"M\" is encoded based on the ASCII standard in bits as\n\"01001101\" as seen in the link above. For convenience, this is often\nwritten as two base-16 numbers (i.e., hexadecimal), where \"0100\"=\"4\" and\n\"1101\"=\"d\", hence we have \"4d\" in hexadecimal.\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\n## 4d in hexadecimal is 'M'\n## 0a is a newline (at least in Linux/Mac)\n## \"0x\" is how we tell Python we are using hexadecimal\n[hex(ord(x)) for x in ['M','o','m','\\n']] ## i.e., \"Mom\\n\" in ascii\nhexvals = b'\\x4d\\x6f\\x6d\\x0a'\n\nwith open('tmp.txt', 'wb') as textfile:\n     nbytes = textfile.write(hexvals)\n\nnbytes\nsubprocess.run([\"ls\", \"-l\", \"tmp.txt\"])\n\nwith open('tmp.txt', 'r') as textfile:\n     line = textfile.readlines()\n\nline\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n['0x4d', '0x6f', '0x6d', '0xa']\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n4\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n-rw-r--r-- 1 paciorek scfstaff 4 Aug 24 17:21 tmp.txt\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\nCompletedProcess(args=['ls', '-l', 'tmp.txt'], returncode=0)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n['Mom\\n']\n```\n:::\n:::\n\n\nWhen encountering non-ASCII files, in some cases you may need to deal\nwith the text encoding (the mapping of individual characters (including\ntabs, returns, etc.) to a set of numeric codes). There are a variety of\ndifferent encodings for text files, with different ones common on\ndifferent operating systems.\n[UTF-8](https://en.wikipedia.org/wiki/UTF-8) is an encoding for the\nUnicode characters that includes more than 110,000 characters from 100\ndifferent alphabets/scripts. It's widely used on the web. Latin-1\nencodes a small subset of Unicode and contains the characters used in\nmany European languages (e.g., letters with accents). Here's an example\nof using a non-ASCII Unicode character:\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\n## n-tilde and division symbol as Unicode 'code points'\n## Python `str` type stores Unicode characters.\nx2_unicode = 'Pe\\u00f1a 3\\u00f72'\nx2_unicode\ntype(x2_unicode)\n\nbytes('\\u00f1', 'utf-8')    # indeed - two bytes, not one\nbytes('\\u00f7', 'utf-8')    # indeed - two bytes, not one\n## specified directly as hexadecimal in UTF-8 encoding \nx2_utf8 = b'Pe\\xc3\\xb1a 3\\xc3\\xb72' \nx2_utf8\n\nwith open('tmp2.txt', 'wb') as textfile:\n     nbytes = textfile.write(x2_utf8)\n\n## Here n-tilde and division symbol take up two bytes\nsubprocess.run([\"ls\", \"-l\", \"tmp2.txt\"])\n## The system knows how to interpret the UTF-8 encoded file\n## and represent the Unicode character on the screen:\nsubprocess.run([\"cat\", \"tmp2.txt\"])\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\n'Peña 3÷2'\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\nstr\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\nb'\\xc3\\xb1'\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\nb'\\xc3\\xb7'\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\nb'Pe\\xc3\\xb1a 3\\xc3\\xb72'\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n-rw-r--r-- 1 paciorek scfstaff 10 Aug 24 17:21 tmp2.txt\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\nCompletedProcess(args=['ls', '-l', 'tmp2.txt'], returncode=0)\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nPeña 3÷2\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\nCompletedProcess(args=['cat', 'tmp2.txt'], returncode=0)\n```\n:::\n:::\n\n\nUTF-8 is cleverly designed in terms of the bit-wise representation of\ncharacters such that ASCII characters still take up one byte, and most\nother characters take two bytes, but some take four bytes. In fact it is\neven more clever than that - the representation is such that the bits of\na one-byte character never appear within the representation of a two-\nor three- or four-byte character (and similarly for two-byte characters\nin three- or four-byte characters, etc.).\n\nThe UNIX utility `file`, e.g. `file tmp.txt` can help provide some\ninformation.\n\nVarious Python functions such as `readlines` allow\n one to specify the encoding as one reads text in.\nThe UNIX utility `iconv` and the Python function `encode` can help with\nconversions.\n\nThe default encoding in Python is UTF-8; note below that\nvarious types of information are interpreted in US English with the\nencoding UTF-8:\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\nimport locale\nlocale.getlocale()\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\n('en_US', 'UTF-8')\n```\n:::\n:::\n\n\nWith strings already in Python, you can convert between encodings with\nthe `encode` method for string objects:\n\n::: {.cell execution_count=37}\n``` {.python .cell-code}\ntext = \"Melhore sua seguran\\xe7a\"\ntext  # automatically encoded as UTF-8\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\n'Melhore sua segurança'\n```\n:::\n:::\n\n\n::: {.cell execution_count=38}\n``` {.python .cell-code}\ntext.encode('latin1')\ntext  \n\ntry:\n    text.encode('ascii')\nexcept Exception as error:\n    print(error)\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\nb'Melhore sua seguran\\xe7a'\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\n'Melhore sua segurança'\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n'ascii' codec can't encode character '\\xe7' in position 19: ordinal not in range(128)\n```\n:::\n:::\n\n\nAn error message about decoding/invalid bytes in the message often indicates\nan encoding issue. In particular errors may arise when trying to do\nread or manipulate strings in Python for which the encoding is\nnot properly set. Here's an example with some Internet logging data that\nwe used a few years ago in class in a problem set and which caused some\nproblems.\n\n::: {.cell execution_count=39}\n``` {.python .cell-code}\ntry:\n    with open('file.txt', 'r') as textfile:\n        lines = textfile.readlines()\nexcept Exception as error:\n    print(error)\n\nwith open('file.txt', 'r', encoding = 'latin1') as textfile:\n    lines = textfile.readlines()\n\n## Note the non-ASCII (Latin-1) character (the upside-down question mark)\nlines[16925]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n'utf-8' codec can't decode byte 0xac in position 7922: invalid start byte\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\n'from 5#c¿a7lw8lz2nX,%@ [128.32.244.179] by ncpc-email with ESMTP\\n'\n```\n:::\n:::\n\n\n# 6. Data structures\n\nAs we're reading data into Python or other languages, it's important to think about the data structures we'll use to store the information. The data structure we choose can affect:\n\n- the amount of memory we need, \n- how quickly we can access the information in the data structure,\n- how much copying needs to be done to add information to or remove information from the data structure,\n- how efficiently we can use the data in subsequent computations.\n\nThis means that what you plan to do with the data should guide what kind of structure you store the data in.\n\n## Standard data structures in Python and R\n\n- In Python and R, one often ends up working with dataframes, lists, and arrays/vectors/matrices/tensors.\n- In Python we commonly work with data structures that are part of additional packages, in particular numpy arrays and pandas dataframes.\n- Dictionaries in Python allow for easy use of key-value pairs where one can access values based on their key/label. In R one can do something similar with named vectors or named lists or (more efficiently) by using environments.\n- In R, if we are not working with rectangular datasets or standard numerical objects, we often end up using lists or enhanced versions of lists, sometimes with deeply nested structures.\n\nIn Unit 7, we'll talk about *distributed* data structures that allow one to easily work with data distributed across multiple computers.\n\n## Other kinds of data structures\n\nYou may have heard of various other kinds of data structures, such as linked lists, trees, graphs, queues, and stacks. One of the key aspects that differentiate such data structures is how one navigates through the elements.\n\n*Sets* are collections of elements that don't have any duplicates (like a mathematical set).\n\nWith a *linked list*, with each element (or node) has a value and a pointer (reference) to the location of the next element. (With a doubly-linked list, there is also a pointer back to the previous element.) One big advantage of this is that one can insert an element by simply modifying the pointers involved at the site of the insertion, without copying any of the other elements in the list. A big disadvantage is that to get to an element you have to navigate through the list. \n\n![Linked list (courtesy of computersciencewiki.org)](linked-list.png)\n\n\nBoth *trees* and *graphs* are collections of nodes (vertices) and links (edges). A tree involves a set of nodes and links to child nodes (also possibly containing information linking the child nodes to their parent nodes). With a graph, the links might not be directional, and there can be cycles.\n\n![Tree (courtesy of computersciencewiki.org)](tree.png)\n\n\n![Graph (courtesy of computersciencewiki.org)](graph.png)\n\n\nA *stack* is a collection of elements that behave like a stack of lunch trays. You can only access the top element directly(\"last in, first out\"), so the operations are that you can push a new element onto the stack or pop the top element off the stack. In fact, nested function calls behave as stacks, and the memory used in the process of evaluating the function calls is called the 'stack'.\n\nA *queue* is like the line at a grocery store, behaving as \"first in, first out\".\n\nOne can use such data structures either directly or via add-on packages in Python and R, though I don't think they're all that commonly used in R. This is probably because statistical/data science/machine learning workflows often involve either 'rectangular' data (i.e., dataframe-style data) and/or mathematical computations with arrays. That said, trees and graphs are widely used.\n\nSome related concepts that we'll discuss further in Unit 5 include:\n\n - types: this refers to how a given piece of information is stored and what operations can be done with the information.\n    - 'primitive' types are the most basic types that often relate directly to how data are stored in memory or on disk (e.g., booleans, integers, numeric (real-valued), character, pointer (address, reference).\n - pointers: references to other locations (addresses) in memory. One often uses pointers to avoid unnecessary copying of data. \n - hashes: hashing involves fast lookup of the value associated with a key (a label), using a hash function, which allows one to convert the key to an address. This avoids having to find the value associated with a specific key by looking through all the keys until the key of interest is found (an O(n) operation).\n\n",
    "supporting": [
      "unit2-dataTech_files"
    ],
    "filters": []
  }
}